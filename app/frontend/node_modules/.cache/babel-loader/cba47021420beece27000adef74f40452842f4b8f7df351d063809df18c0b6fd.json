{"ast":null,"code":"const SignalingClient = require('amazon-kinesis-video-streams-webrtc').SignalingClient;\nconst KVSWebRTC = require('amazon-kinesis-video-streams-webrtc');\n\n// Function to request signaling channel endpoint and ICE server configuration from the server\nasync function getSignalingChannelConfig(channelARN) {\n  const response = await fetch(`http://localhost:5001/getSignalingChannelConfig?channelARN=${encodeURIComponent(channelARN)}`);\n  if (!response.ok) {\n    throw new Error(`Failed to get signaling channel config: ${response.statusText}`);\n  }\n  return response.json();\n}\n\n// Function to create and configure the peer connection\nfunction createPeerConnection(iceServers, localView, remoteView) {\n  const peerConnectionConfig = {\n    iceServers\n  };\n  const peerConnection = new RTCPeerConnection(peerConnectionConfig);\n\n  // Handle local stream\n  navigator.mediaDevices.getUserMedia({\n    video: true,\n    audio: true\n  }).then(localStream => {\n    localView.srcObject = localStream;\n    localStream.getTracks().forEach(track => peerConnection.addTrack(track, localStream));\n  }).catch(error => console.error('Error getting local stream', error));\n\n  // As remote tracks are received, add them to the remote view\n  peerConnection.addEventListener('track', event => {\n    if (remoteView.srcObject) {\n      return;\n    }\n    remoteView.srcObject = event.streams[0];\n  });\n  return peerConnection;\n}\n\n// Main function to initialize WebRTC connection\nexport async function initializeWebRTC(channelARN, localView, remoteView) {\n  try {\n    const config = await getSignalingChannelConfig(channelARN);\n    const {\n      endpointsByProtocol,\n      iceServers\n    } = config;\n    const accessKeyId = 'ASIAWZJFG3PROK2SSARP';\n    const secretAccessKey = 'eVnIhkUPKPj0LyzglX3GGVgxKaHIuJf/pgV1dNkp';\n    const signalingClient = new KVSWebRTC.SignalingClient({\n      channelARN,\n      channelEndpoint: endpointsByProtocol.WSS,\n      clientId,\n      role: KVSWebRTC.Role.VIEWER,\n      region,\n      credentials: {\n        accessKeyId,\n        secretAccessKey\n      },\n      systemClockOffset: kinesisVideoClient.config.systemClockOffset\n    });\n    const peerConnection = createPeerConnection(iceServers, localView, remoteView);\n\n    // Set up signaling client event listeners\n    signalingClient.on('open', async () => {\n      console.log('Signaling client connection opened');\n      // Implement logic when signaling connection is opened\n    });\n\n    signalingClient.on('sdpOffer', async offer => {\n      console.log('Received SDP Offer');\n      // Handle the SDP offer\n      await peerConnection.setRemoteDescription(offer);\n      const answer = await peerConnection.createAnswer();\n      await peerConnection.setLocalDescription(answer);\n      signalingClient.sendSdpAnswer(answer);\n    });\n    signalingClient.on('iceCandidate', async candidate => {\n      console.log('Received ICE Candidate');\n      // Add the ICE candidate to the peer connection\n      peerConnection.addIceCandidate(candidate);\n    });\n\n    // More event listeners as needed...\n\n    // Handle ICE candidates from the peer connection\n    peerConnection.onicecandidate = event => {\n      if (event.candidate) {\n        signalingClient.sendIceCandidate(event.candidate);\n      }\n    };\n    signalingClient.open();\n    console.log('Signaling Client and Peer Connection created');\n    return {\n      signalingClient,\n      peerConnection\n    };\n  } catch (error) {\n    console.error('Error initializing WebRTC: ', error);\n  }\n}\nexport function cleanupWebRTC(signalingClient, peerConnection) {\n  if (signalingClient) {\n    signalingClient.close();\n  }\n  if (peerConnection) {\n    peerConnection.close();\n  }\n}","map":{"version":3,"names":["SignalingClient","require","KVSWebRTC","getSignalingChannelConfig","channelARN","response","fetch","encodeURIComponent","ok","Error","statusText","json","createPeerConnection","iceServers","localView","remoteView","peerConnectionConfig","peerConnection","RTCPeerConnection","navigator","mediaDevices","getUserMedia","video","audio","then","localStream","srcObject","getTracks","forEach","track","addTrack","catch","error","console","addEventListener","event","streams","initializeWebRTC","config","endpointsByProtocol","accessKeyId","secretAccessKey","signalingClient","channelEndpoint","WSS","clientId","role","Role","VIEWER","region","credentials","systemClockOffset","kinesisVideoClient","on","log","offer","setRemoteDescription","answer","createAnswer","setLocalDescription","sendSdpAnswer","candidate","addIceCandidate","onicecandidate","sendIceCandidate","open","cleanupWebRTC","close"],"sources":["/Users/xuximin/Desktop/499/year-long-project-team-6/app/frontend/src/pages/webrtc.js"],"sourcesContent":["const SignalingClient = require('amazon-kinesis-video-streams-webrtc').SignalingClient;\nconst KVSWebRTC = require('amazon-kinesis-video-streams-webrtc');\n\n// Function to request signaling channel endpoint and ICE server configuration from the server\nasync function getSignalingChannelConfig(channelARN) {\n    const response = await fetch(`http://localhost:5001/getSignalingChannelConfig?channelARN=${encodeURIComponent(channelARN)}`);\n    if (!response.ok) {\n        throw new Error(`Failed to get signaling channel config: ${response.statusText}`);\n    }\n    return response.json();\n}\n\n// Function to create and configure the peer connection\nfunction createPeerConnection(iceServers, localView, remoteView) {\n    const peerConnectionConfig = {\n        iceServers\n    };\n    const peerConnection = new RTCPeerConnection(peerConnectionConfig);\n\n    // Handle local stream\n    navigator.mediaDevices.getUserMedia({ video: true, audio: true })\n        .then(localStream => {\n            localView.srcObject = localStream;\n            localStream.getTracks().forEach(track => peerConnection.addTrack(track, localStream));\n        })\n        .catch(error => console.error('Error getting local stream', error));\n\n    // As remote tracks are received, add them to the remote view\n    peerConnection.addEventListener('track', event => {\n        if (remoteView.srcObject) {\n            return;\n        }\n        remoteView.srcObject = event.streams[0];\n    });\n\n    return peerConnection;\n}\n\n// Main function to initialize WebRTC connection\nexport async function initializeWebRTC(channelARN, localView, remoteView) {\n    try {\n        const config = await getSignalingChannelConfig(channelARN);\n        const { endpointsByProtocol, iceServers } = config;\n        const accessKeyId='ASIAWZJFG3PROK2SSARP';\n        const secretAccessKey='eVnIhkUPKPj0LyzglX3GGVgxKaHIuJf/pgV1dNkp';\n        const signalingClient = new KVSWebRTC.SignalingClient({\n            channelARN,\n            channelEndpoint: endpointsByProtocol.WSS,\n            clientId,\n            role: KVSWebRTC.Role.VIEWER,\n            region,\n            credentials: {\n                accessKeyId,\n                secretAccessKey,\n            },\n            systemClockOffset: kinesisVideoClient.config.systemClockOffset,\n        });\n\n        const peerConnection = createPeerConnection(iceServers, localView, remoteView);\n\n        // Set up signaling client event listeners\n        signalingClient.on('open', async () => {\n            console.log('Signaling client connection opened');\n            // Implement logic when signaling connection is opened\n        });\n\n        signalingClient.on('sdpOffer', async (offer) => {\n            console.log('Received SDP Offer');\n            // Handle the SDP offer\n            await peerConnection.setRemoteDescription(offer);\n            const answer = await peerConnection.createAnswer();\n            await peerConnection.setLocalDescription(answer);\n            signalingClient.sendSdpAnswer(answer);\n        });\n\n        signalingClient.on('iceCandidate', async (candidate) => {\n            console.log('Received ICE Candidate');\n            // Add the ICE candidate to the peer connection\n            peerConnection.addIceCandidate(candidate);\n        });\n\n        // More event listeners as needed...\n\n        // Handle ICE candidates from the peer connection\n        peerConnection.onicecandidate = event => {\n            if (event.candidate) {\n                signalingClient.sendIceCandidate(event.candidate);\n            }\n        };\n\n        signalingClient.open();\n        console.log('Signaling Client and Peer Connection created');\n        return { signalingClient, peerConnection };\n    } catch (error) {\n        console.error('Error initializing WebRTC: ', error);\n    }\n}\n\nexport function cleanupWebRTC(signalingClient, peerConnection) {\n    if (signalingClient) {\n        signalingClient.close();\n    }\n    if (peerConnection) {\n        peerConnection.close();\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}