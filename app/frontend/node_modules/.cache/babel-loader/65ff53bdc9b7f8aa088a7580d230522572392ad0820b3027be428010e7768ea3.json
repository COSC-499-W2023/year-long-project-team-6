{"ast":null,"code":"const SignalingClient = require('amazon-kinesis-video-streams-webrtc').SignalingClient;\nconst KVSWebRTC = require('amazon-kinesis-video-streams-webrtc');\n// Add at the top of your webrtc.js\nconst uploadVideo = async blob => {\n  const formData = new FormData();\n  formData.append('video', blob, 'video.webm'); // Adjust the file name as needed\n\n  try {\n    const response = await fetch('http://localhost:5001/upload-video', {\n      method: 'POST',\n      body: formData\n    });\n    const result = await response.json();\n    console.log('Upload result:', result);\n    return result; // Return the result for further processing if needed\n  } catch (error) {\n    console.error('Error uploading video:', error);\n    throw error; // Throw the error to be handled by the caller\n  }\n};\n\n// Export the function\nexport { uploadVideo };\n\n// Function to request signaling channel endpoint and ICE server configuration from the server\nasync function getSignalingChannelConfig(channelARN) {\n  const response = await fetch(`http://localhost:5001/getSignalingChannelConfig?channelARN=${encodeURIComponent(channelARN)}`);\n  if (!response.ok) {\n    throw new Error(`Failed to get signaling channel config: ${response.statusText}`);\n  }\n  const config = await response.json();\n  console.log(\"Received config from server:\", config);\n  return config;\n}\n\n// Function to fetch temporary AWS credentials\nasync function fetchCredentials() {\n  try {\n    const response = await fetch('http://localhost:5001/get-temp-credentials');\n    if (!response.ok) {\n      throw new Error('Failed to fetch credentials: ' + response.statusText);\n    }\n    const data = await response.json();\n    return {\n      accessKeyId: data.accessKeyId,\n      secretAccessKey: data.secretAccessKey,\n      sessionToken: data.sessionToken\n    };\n  } catch (error) {\n    console.error('Error fetching credentials from server:', error);\n    throw error;\n  }\n}\n\n// Function to create and configure the peer connection\nfunction createPeerConnection(iceServers) {\n  const peerConnectionConfig = {\n    iceServers\n  };\n  const peerConnection = new RTCPeerConnection(peerConnectionConfig);\n  return peerConnection;\n}\n\n// Main function to initialize WebRTC connection\nexport async function initializeWebRTC(channelARN, localView) {\n  try {\n    const config = await getSignalingChannelConfig(channelARN);\n    const {\n      endpointsByProtocol,\n      iceServers\n    } = config;\n    const credentials = await fetchCredentials();\n    const peerConnection = createPeerConnection(iceServers);\n    let localStream = null;\n    try {\n      localStream = await navigator.mediaDevices.getUserMedia({\n        video: {\n          width: {\n            ideal: 1280\n          },\n          height: {\n            ideal: 720\n          }\n        },\n        audio: true\n      });\n      localStream.getTracks().forEach(track => peerConnection.addTrack(track, localStream));\n      localView.srcObject = localStream;\n    } catch (e) {\n      console.error(\"Error getting local stream:\", e);\n      return;\n    }\n    const signalingClient = new SignalingClient({\n      channelARN,\n      channelEndpoint: endpointsByProtocol.WSS,\n      clientId: '23',\n      // Customize clientId as needed\n      role: KVSWebRTC.Role.VIEWER,\n      region: 'us-east-1',\n      credentials: credentials\n    });\n    signalingClient.open();\n    signalingClient.on('open', async () => {\n      const offer = await peerConnection.createOffer({\n        offerToReceiveAudio: true,\n        offerToReceiveVideo: true\n      });\n      await peerConnection.setLocalDescription(offer);\n      signalingClient.sendSdpOffer(peerConnection.localDescription);\n    });\n    signalingClient.on('sdpAnswer', async answer => {\n      await peerConnection.setRemoteDescription(answer);\n    });\n    signalingClient.on('iceCandidate', candidate => {\n      peerConnection.addIceCandidate(candidate);\n    });\n    return {\n      signalingClient,\n      peerConnection,\n      localStream\n    };\n  } catch (error) {\n    console.error('Error initializing WebRTC: ', error);\n  }\n}\nexport function cleanupWebRTC(signalingClient, peerConnection) {\n  console.log(\"WebRTC is cleaned up\");\n  if (signalingClient) {\n    signalingClient.close();\n  }\n  if (peerConnection) {\n    peerConnection.getSenders().forEach(sender => {\n      if (sender.track) {\n        sender.track.stop();\n      }\n    });\n    peerConnection.close();\n  }\n}","map":{"version":3,"names":["SignalingClient","require","KVSWebRTC","uploadVideo","blob","formData","FormData","append","response","fetch","method","body","result","json","console","log","error","getSignalingChannelConfig","channelARN","encodeURIComponent","ok","Error","statusText","config","fetchCredentials","data","accessKeyId","secretAccessKey","sessionToken","createPeerConnection","iceServers","peerConnectionConfig","peerConnection","RTCPeerConnection","initializeWebRTC","localView","endpointsByProtocol","credentials","localStream","navigator","mediaDevices","getUserMedia","video","width","ideal","height","audio","getTracks","forEach","track","addTrack","srcObject","e","signalingClient","channelEndpoint","WSS","clientId","role","Role","VIEWER","region","open","on","offer","createOffer","offerToReceiveAudio","offerToReceiveVideo","setLocalDescription","sendSdpOffer","localDescription","answer","setRemoteDescription","candidate","addIceCandidate","cleanupWebRTC","close","getSenders","sender","stop"],"sources":["/Users/xuximin/Desktop/499/year-long-project-team-6/app/frontend/src/pages/webrtc.js"],"sourcesContent":["const SignalingClient = require('amazon-kinesis-video-streams-webrtc').SignalingClient;\nconst KVSWebRTC = require('amazon-kinesis-video-streams-webrtc');\n// Add at the top of your webrtc.js\nconst uploadVideo = async (blob) => {\n    const formData = new FormData();\n    formData.append('video', blob, 'video.webm'); // Adjust the file name as needed\n\n    try {\n        const response = await fetch('http://localhost:5001/upload-video', {\n            method: 'POST',\n            body: formData,\n        });\n\n        const result = await response.json();\n        console.log('Upload result:', result);\n        return result; // Return the result for further processing if needed\n    } catch (error) {\n        console.error('Error uploading video:', error);\n        throw error; // Throw the error to be handled by the caller\n    }\n};\n\n// Export the function\nexport { uploadVideo };\n\n// Function to request signaling channel endpoint and ICE server configuration from the server\nasync function getSignalingChannelConfig(channelARN) {\n    const response = await fetch(`http://localhost:5001/getSignalingChannelConfig?channelARN=${encodeURIComponent(channelARN)}`);\n    if (!response.ok) {\n        throw new Error(`Failed to get signaling channel config: ${response.statusText}`);\n    }\n    const config = await response.json();\n    console.log(\"Received config from server:\", config);\n    return config;\n}\n\n// Function to fetch temporary AWS credentials\nasync function fetchCredentials() {\n    try {\n        const response = await fetch('http://localhost:5001/get-temp-credentials');\n        if (!response.ok) {\n            throw new Error('Failed to fetch credentials: ' + response.statusText);\n        }\n        const data = await response.json();\n        return {\n            accessKeyId: data.accessKeyId,\n            secretAccessKey: data.secretAccessKey,\n            sessionToken: data.sessionToken\n        };\n    } catch (error) {\n        console.error('Error fetching credentials from server:', error);\n        throw error;\n    }\n}\n\n// Function to create and configure the peer connection\nfunction createPeerConnection(iceServers) {\n    const peerConnectionConfig = { iceServers };\n    const peerConnection = new RTCPeerConnection(peerConnectionConfig);\n    return peerConnection;\n}\n\n// Main function to initialize WebRTC connection\nexport async function initializeWebRTC(channelARN, localView) {\n    try {\n        const config = await getSignalingChannelConfig(channelARN);\n        const { endpointsByProtocol, iceServers } = config;\n        const credentials = await fetchCredentials();\n\n        const peerConnection = createPeerConnection(iceServers);\n        let localStream = null;\n\n        try {\n            localStream = await navigator.mediaDevices.getUserMedia({\n                video: { width: { ideal: 1280 }, height: { ideal: 720 } },\n                audio: true,\n            });\n            localStream.getTracks().forEach(track => peerConnection.addTrack(track, localStream));\n            localView.srcObject = localStream;\n        } catch (e) {\n            console.error(\"Error getting local stream:\", e);\n            return;\n        }\n\n        const signalingClient = new SignalingClient({\n            channelARN,\n            channelEndpoint: endpointsByProtocol.WSS,\n            clientId: '23', // Customize clientId as needed\n            role: KVSWebRTC.Role.VIEWER,\n            region: 'us-east-1',\n            credentials: credentials\n        });\n\n        signalingClient.open();\n\n        signalingClient.on('open', async () => {\n            const offer = await peerConnection.createOffer({\n                offerToReceiveAudio: true,\n                offerToReceiveVideo: true,\n            });\n            await peerConnection.setLocalDescription(offer);\n            signalingClient.sendSdpOffer(peerConnection.localDescription);\n        });\n\n        signalingClient.on('sdpAnswer', async answer => {\n            await peerConnection.setRemoteDescription(answer);\n        });\n\n        signalingClient.on('iceCandidate', candidate => {\n            peerConnection.addIceCandidate(candidate);\n        });\n\n        return { signalingClient, peerConnection, localStream };\n    } catch (error) {\n        console.error('Error initializing WebRTC: ', error);\n    }\n}\n\nexport function cleanupWebRTC(signalingClient, peerConnection) {\n    console.log(\"WebRTC is cleaned up\");\n    if (signalingClient) {\n        signalingClient.close();\n    }\n\n    if (peerConnection) {\n        peerConnection.getSenders().forEach(sender => {\n            if (sender.track) {\n                sender.track.stop();\n            }\n        });\n        peerConnection.close();\n    }\n}\n"],"mappings":"AAAA,MAAMA,eAAe,GAAGC,OAAO,CAAC,qCAAqC,CAAC,CAACD,eAAe;AACtF,MAAME,SAAS,GAAGD,OAAO,CAAC,qCAAqC,CAAC;AAChE;AACA,MAAME,WAAW,GAAG,MAAOC,IAAI,IAAK;EAChC,MAAMC,QAAQ,GAAG,IAAIC,QAAQ,CAAC,CAAC;EAC/BD,QAAQ,CAACE,MAAM,CAAC,OAAO,EAAEH,IAAI,EAAE,YAAY,CAAC,CAAC,CAAC;;EAE9C,IAAI;IACA,MAAMI,QAAQ,GAAG,MAAMC,KAAK,CAAC,oCAAoC,EAAE;MAC/DC,MAAM,EAAE,MAAM;MACdC,IAAI,EAAEN;IACV,CAAC,CAAC;IAEF,MAAMO,MAAM,GAAG,MAAMJ,QAAQ,CAACK,IAAI,CAAC,CAAC;IACpCC,OAAO,CAACC,GAAG,CAAC,gBAAgB,EAAEH,MAAM,CAAC;IACrC,OAAOA,MAAM,CAAC,CAAC;EACnB,CAAC,CAAC,OAAOI,KAAK,EAAE;IACZF,OAAO,CAACE,KAAK,CAAC,wBAAwB,EAAEA,KAAK,CAAC;IAC9C,MAAMA,KAAK,CAAC,CAAC;EACjB;AACJ,CAAC;;AAED;AACA,SAASb,WAAW;;AAEpB;AACA,eAAec,yBAAyBA,CAACC,UAAU,EAAE;EACjD,MAAMV,QAAQ,GAAG,MAAMC,KAAK,CAAE,8DAA6DU,kBAAkB,CAACD,UAAU,CAAE,EAAC,CAAC;EAC5H,IAAI,CAACV,QAAQ,CAACY,EAAE,EAAE;IACd,MAAM,IAAIC,KAAK,CAAE,2CAA0Cb,QAAQ,CAACc,UAAW,EAAC,CAAC;EACrF;EACA,MAAMC,MAAM,GAAG,MAAMf,QAAQ,CAACK,IAAI,CAAC,CAAC;EACpCC,OAAO,CAACC,GAAG,CAAC,8BAA8B,EAAEQ,MAAM,CAAC;EACnD,OAAOA,MAAM;AACjB;;AAEA;AACA,eAAeC,gBAAgBA,CAAA,EAAG;EAC9B,IAAI;IACA,MAAMhB,QAAQ,GAAG,MAAMC,KAAK,CAAC,4CAA4C,CAAC;IAC1E,IAAI,CAACD,QAAQ,CAACY,EAAE,EAAE;MACd,MAAM,IAAIC,KAAK,CAAC,+BAA+B,GAAGb,QAAQ,CAACc,UAAU,CAAC;IAC1E;IACA,MAAMG,IAAI,GAAG,MAAMjB,QAAQ,CAACK,IAAI,CAAC,CAAC;IAClC,OAAO;MACHa,WAAW,EAAED,IAAI,CAACC,WAAW;MAC7BC,eAAe,EAAEF,IAAI,CAACE,eAAe;MACrCC,YAAY,EAAEH,IAAI,CAACG;IACvB,CAAC;EACL,CAAC,CAAC,OAAOZ,KAAK,EAAE;IACZF,OAAO,CAACE,KAAK,CAAC,yCAAyC,EAAEA,KAAK,CAAC;IAC/D,MAAMA,KAAK;EACf;AACJ;;AAEA;AACA,SAASa,oBAAoBA,CAACC,UAAU,EAAE;EACtC,MAAMC,oBAAoB,GAAG;IAAED;EAAW,CAAC;EAC3C,MAAME,cAAc,GAAG,IAAIC,iBAAiB,CAACF,oBAAoB,CAAC;EAClE,OAAOC,cAAc;AACzB;;AAEA;AACA,OAAO,eAAeE,gBAAgBA,CAAChB,UAAU,EAAEiB,SAAS,EAAE;EAC1D,IAAI;IACA,MAAMZ,MAAM,GAAG,MAAMN,yBAAyB,CAACC,UAAU,CAAC;IAC1D,MAAM;MAAEkB,mBAAmB;MAAEN;IAAW,CAAC,GAAGP,MAAM;IAClD,MAAMc,WAAW,GAAG,MAAMb,gBAAgB,CAAC,CAAC;IAE5C,MAAMQ,cAAc,GAAGH,oBAAoB,CAACC,UAAU,CAAC;IACvD,IAAIQ,WAAW,GAAG,IAAI;IAEtB,IAAI;MACAA,WAAW,GAAG,MAAMC,SAAS,CAACC,YAAY,CAACC,YAAY,CAAC;QACpDC,KAAK,EAAE;UAAEC,KAAK,EAAE;YAAEC,KAAK,EAAE;UAAK,CAAC;UAAEC,MAAM,EAAE;YAAED,KAAK,EAAE;UAAI;QAAE,CAAC;QACzDE,KAAK,EAAE;MACX,CAAC,CAAC;MACFR,WAAW,CAACS,SAAS,CAAC,CAAC,CAACC,OAAO,CAACC,KAAK,IAAIjB,cAAc,CAACkB,QAAQ,CAACD,KAAK,EAAEX,WAAW,CAAC,CAAC;MACrFH,SAAS,CAACgB,SAAS,GAAGb,WAAW;IACrC,CAAC,CAAC,OAAOc,CAAC,EAAE;MACRtC,OAAO,CAACE,KAAK,CAAC,6BAA6B,EAAEoC,CAAC,CAAC;MAC/C;IACJ;IAEA,MAAMC,eAAe,GAAG,IAAIrD,eAAe,CAAC;MACxCkB,UAAU;MACVoC,eAAe,EAAElB,mBAAmB,CAACmB,GAAG;MACxCC,QAAQ,EAAE,IAAI;MAAE;MAChBC,IAAI,EAAEvD,SAAS,CAACwD,IAAI,CAACC,MAAM;MAC3BC,MAAM,EAAE,WAAW;MACnBvB,WAAW,EAAEA;IACjB,CAAC,CAAC;IAEFgB,eAAe,CAACQ,IAAI,CAAC,CAAC;IAEtBR,eAAe,CAACS,EAAE,CAAC,MAAM,EAAE,YAAY;MACnC,MAAMC,KAAK,GAAG,MAAM/B,cAAc,CAACgC,WAAW,CAAC;QAC3CC,mBAAmB,EAAE,IAAI;QACzBC,mBAAmB,EAAE;MACzB,CAAC,CAAC;MACF,MAAMlC,cAAc,CAACmC,mBAAmB,CAACJ,KAAK,CAAC;MAC/CV,eAAe,CAACe,YAAY,CAACpC,cAAc,CAACqC,gBAAgB,CAAC;IACjE,CAAC,CAAC;IAEFhB,eAAe,CAACS,EAAE,CAAC,WAAW,EAAE,MAAMQ,MAAM,IAAI;MAC5C,MAAMtC,cAAc,CAACuC,oBAAoB,CAACD,MAAM,CAAC;IACrD,CAAC,CAAC;IAEFjB,eAAe,CAACS,EAAE,CAAC,cAAc,EAAEU,SAAS,IAAI;MAC5CxC,cAAc,CAACyC,eAAe,CAACD,SAAS,CAAC;IAC7C,CAAC,CAAC;IAEF,OAAO;MAAEnB,eAAe;MAAErB,cAAc;MAAEM;IAAY,CAAC;EAC3D,CAAC,CAAC,OAAOtB,KAAK,EAAE;IACZF,OAAO,CAACE,KAAK,CAAC,6BAA6B,EAAEA,KAAK,CAAC;EACvD;AACJ;AAEA,OAAO,SAAS0D,aAAaA,CAACrB,eAAe,EAAErB,cAAc,EAAE;EAC3DlB,OAAO,CAACC,GAAG,CAAC,sBAAsB,CAAC;EACnC,IAAIsC,eAAe,EAAE;IACjBA,eAAe,CAACsB,KAAK,CAAC,CAAC;EAC3B;EAEA,IAAI3C,cAAc,EAAE;IAChBA,cAAc,CAAC4C,UAAU,CAAC,CAAC,CAAC5B,OAAO,CAAC6B,MAAM,IAAI;MAC1C,IAAIA,MAAM,CAAC5B,KAAK,EAAE;QACd4B,MAAM,CAAC5B,KAAK,CAAC6B,IAAI,CAAC,CAAC;MACvB;IACJ,CAAC,CAAC;IACF9C,cAAc,CAAC2C,KAAK,CAAC,CAAC;EAC1B;AACJ"},"metadata":{},"sourceType":"module","externalDependencies":[]}