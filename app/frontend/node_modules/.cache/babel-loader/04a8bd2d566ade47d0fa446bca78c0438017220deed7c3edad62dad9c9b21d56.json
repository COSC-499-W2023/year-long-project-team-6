{"ast":null,"code":"const SignalingClient = require('amazon-kinesis-video-streams-webrtc').SignalingClient;\nconst KVSWebRTC = require('amazon-kinesis-video-streams-webrtc');\n\n// Function to request signaling channel endpoint and ICE server configuration from the server\nasync function getSignalingChannelConfig(channelARN) {\n  const response = await fetch(`http://localhost:5001/getSignalingChannelConfig?channelARN=${encodeURIComponent(channelARN)}`);\n  if (!response.ok) {\n    throw new Error(`Failed to get signaling channel config: ${response.statusText}`);\n  }\n  const config = await response.json();\n  console.log(\"Received config from server:\", config);\n  return config;\n}\nasync function fetchCredentials() {\n  try {\n    const response = await fetch('/get-temp-credentials');\n    if (!response.ok) {\n      throw new Error('Failed to fetch credentials');\n    }\n    const credentials = await response.json();\n    return credentials;\n  } catch (error) {\n    console.error('Error fetching credentials:', error);\n    throw error;\n  }\n}\n// Function to create and configure the peer connection\nfunction createPeerConnection(iceServers, localView, remoteView) {\n  const peerConnectionConfig = {\n    iceServers\n  };\n  const peerConnection = new RTCPeerConnection(peerConnectionConfig);\n\n  // Handle local stream\n  navigator.mediaDevices.getUserMedia({\n    video: true,\n    audio: true\n  }).then(localStream => {\n    localView.srcObject = localStream;\n    localStream.getTracks().forEach(track => peerConnection.addTrack(track, localStream));\n  }).catch(error => console.error('Error getting local stream', error));\n\n  // As remote tracks are received, add them to the remote view\n  peerConnection.addEventListener('track', event => {\n    if (remoteView.srcObject) {\n      return;\n    }\n    remoteView.srcObject = event.streams[0];\n  });\n  return peerConnection;\n}\n\n// Main function to initialize WebRTC connection\nexport async function initializeWebRTC(channelARN, localView, remoteView) {\n  try {\n    const config = await getSignalingChannelConfig(channelARN);\n    const {\n      endpointsByProtocol,\n      iceServers\n    } = config;\n\n    // Now use temporaryCredentials to initialize SignalingClient\n    const signalingClient = new SignalingClient({\n      channelARN,\n      channelEndpoint: endpointsByProtocol.WSS,\n      clientId: '23',\n      role: KVSWebRTC.Role.VIEWER,\n      region: 'us-east-1',\n      // Add the temporary credentials or token here\n      credentials: {\n        accessKeyId: 'ASIAWZJFG3PROK2SSARP',\n        // Ensure these fields are correctly populated\n        secretAccessKey: 'eVnIhkUPKPj0LyzglX3GGVgxKaHIuJf/pgV1dNkp',\n        sessionToken: 'IQoJb3JpZ2luX2VjENP//////////wEaDGNhLWNlbnRyYWwtMSJIMEYCIQCFEVcYpoONj3IQAlAfFL+ufHCQtC8KWwAYzND2KUyTPgIhAOc5ENL5KVOQIG8/+BTWV5BVlflal8SpyQv1kq8e4nJ5KokDCDwQABoMNDY2NjE4ODY2NjU4Igzt0lhGeLTOQvWsruQq5gJGFB/HzMrwDnjZ2z+J0PFoPkuecHi7WlSPYXKUz9smDW+wMPc/aKQlfrAdzv40AivwsnCPYHoDPpFopqnhGBlbljalg2P0f+d3oHEyL3CiPmzZxZ8mTaEIp5Ij8WA+GRXZ5PWSQ7YMTdv/mLenHXqd7LbUpdFzGQVZlcu+Dpanm/8mKPaDqX71ddKa0HkakqXlZXB1186TzEXMjg+qdKN6LJCzoFPlUMon1MecRE28Fs9QTFvAo3foj3Dts12hFRAajxwxS7yM8QVUJD24b1eUZ0opFR378YqFC172l6vb3Ej3LQMsD8q65ql4V0WuqJRnjvu3o3PM8WtQ4BW3U7mxSI/Hs+JI/u7mPyc4LqZGt2xyg4nMWP60WXuPHXJAYR2zilKLyTHzRxwEXESryntqvQLqGfpf8yE7h+5QolUTPX40Lfs/Ugv1knEpz83ktS8Gq8NIVGWDeaN9d/rv4UkCRivZ3ao0MJ3er6sGOqUBOuL7G4MhECk2cuhTZcuiQKVk3B4xyOkwccKlC9HeyWBRp1yTN5fp5fMDw01JnlSpERZBmvSPzgUy5N/b+OYFIOsi5uJ5/cRDeIWZH/2yh7aq2xwyYaJgINEB0HXAvkDNkagmMbUdhvc+LpBik1/W+/P0n9fQGu1CnXzKzNc52HMfUiA25CzHQTDAlI2CTh3JrZjMi9NoEf9ZISS2byOWOU7uORka'\n      }\n    });\n    const peerConnection = createPeerConnection(iceServers, localView, remoteView);\n\n    // Set up signaling client event listeners and peer connection logic\n    // signalingClient.on('open', ...), signalingClient.on('sdpAnswer', ...), etc.\n\n    signalingClient.open();\n    signalingClient.on('open', async () => {\n      // Get a stream from the webcam, add it to the peer connection, and display it in the local view\n      try {\n        const localStream = await navigator.mediaDevices.getUserMedia({\n          video: {\n            width: {\n              ideal: 1280\n            },\n            height: {\n              ideal: 720\n            }\n          },\n          audio: true\n        });\n        localStream.getTracks().forEach(track => peerConnection.addTrack(track, localStream));\n        localView.srcObject = localStream;\n      } catch (e) {\n        console.error(\"Error getting local stream:\", e);\n        return;\n      }\n\n      // Create an SDP offer and send it to the master\n      const offer = await peerConnection.createOffer({\n        offerToReceiveAudio: true,\n        offerToReceiveVideo: true\n      });\n      await peerConnection.setLocalDescription(offer);\n      signalingClient.sendSdpOffer(peerConnection.localDescription);\n    });\n\n    // When the SDP answer is received back from the master, add it to the peer connection.\n    signalingClient.on('sdpAnswer', async answer => {\n      await peerConnection.setRemoteDescription(answer);\n    });\n\n    // When an ICE candidate is received from the master, add it to the peer connection.\n    signalingClient.on('iceCandidate', candidate => {\n      peerConnection.addIceCandidate(candidate);\n    });\n    return {\n      signalingClient,\n      peerConnection\n    };\n  } catch (error) {\n    console.error('Error initializing WebRTC: ', error);\n  }\n}\nexport function cleanupWebRTC(signalingClient, peerConnection) {\n  if (signalingClient) {\n    signalingClient.close();\n  }\n  if (peerConnection) {\n    peerConnection.close();\n  }\n}","map":{"version":3,"names":["SignalingClient","require","KVSWebRTC","getSignalingChannelConfig","channelARN","response","fetch","encodeURIComponent","ok","Error","statusText","config","json","console","log","fetchCredentials","credentials","error","createPeerConnection","iceServers","localView","remoteView","peerConnectionConfig","peerConnection","RTCPeerConnection","navigator","mediaDevices","getUserMedia","video","audio","then","localStream","srcObject","getTracks","forEach","track","addTrack","catch","addEventListener","event","streams","initializeWebRTC","endpointsByProtocol","signalingClient","channelEndpoint","WSS","clientId","role","Role","VIEWER","region","accessKeyId","secretAccessKey","sessionToken","open","on","width","ideal","height","e","offer","createOffer","offerToReceiveAudio","offerToReceiveVideo","setLocalDescription","sendSdpOffer","localDescription","answer","setRemoteDescription","candidate","addIceCandidate","cleanupWebRTC","close"],"sources":["/Users/xuximin/Desktop/499/year-long-project-team-6/app/frontend/src/pages/webrtc.js"],"sourcesContent":["const SignalingClient = require('amazon-kinesis-video-streams-webrtc').SignalingClient;\nconst KVSWebRTC = require('amazon-kinesis-video-streams-webrtc');\n\n// Function to request signaling channel endpoint and ICE server configuration from the server\nasync function getSignalingChannelConfig(channelARN) {\n    const response = await fetch(`http://localhost:5001/getSignalingChannelConfig?channelARN=${encodeURIComponent(channelARN)}`);\n    if (!response.ok) {\n        throw new Error(`Failed to get signaling channel config: ${response.statusText}`);\n    }\n    const config = await response.json();\nconsole.log(\"Received config from server:\", config);\nreturn config;\n\n}\nasync function fetchCredentials() {\n    try {\n        const response = await fetch('/get-temp-credentials');\n        if (!response.ok) {\n            throw new Error('Failed to fetch credentials');\n        }\n        const credentials = await response.json();\n        return credentials;\n    } catch (error) {\n        console.error('Error fetching credentials:', error);\n        throw error;\n    }\n}\n// Function to create and configure the peer connection\nfunction createPeerConnection(iceServers, localView, remoteView) {\n    const peerConnectionConfig = {\n        iceServers\n    };\n    const peerConnection = new RTCPeerConnection(peerConnectionConfig);\n\n    // Handle local stream\n    navigator.mediaDevices.getUserMedia({ video: true, audio: true })\n        .then(localStream => {\n            localView.srcObject = localStream;\n            localStream.getTracks().forEach(track => peerConnection.addTrack(track, localStream));\n        })\n        .catch(error => console.error('Error getting local stream', error));\n\n    // As remote tracks are received, add them to the remote view\n    peerConnection.addEventListener('track', event => {\n        if (remoteView.srcObject) {\n            return;\n        }\n        remoteView.srcObject = event.streams[0];\n    });\n\n    return peerConnection;\n}\n\n// Main function to initialize WebRTC connection\nexport async function initializeWebRTC(channelARN, localView, remoteView) {\n    try {\n        const config = await getSignalingChannelConfig(channelARN);\n        const { endpointsByProtocol, iceServers } = config;\n\n        // Now use temporaryCredentials to initialize SignalingClient\n        const signalingClient = new SignalingClient({\n            channelARN,\n            channelEndpoint: endpointsByProtocol.WSS,\n            clientId: '23', \n            role: KVSWebRTC.Role.VIEWER,\n            region: 'us-east-1',\n            // Add the temporary credentials or token here\n            credentials: {\n                accessKeyId: 'ASIAWZJFG3PROK2SSARP', // Ensure these fields are correctly populated\n                secretAccessKey: 'eVnIhkUPKPj0LyzglX3GGVgxKaHIuJf/pgV1dNkp',\n                sessionToken: 'IQoJb3JpZ2luX2VjENP//////////wEaDGNhLWNlbnRyYWwtMSJIMEYCIQCFEVcYpoONj3IQAlAfFL+ufHCQtC8KWwAYzND2KUyTPgIhAOc5ENL5KVOQIG8/+BTWV5BVlflal8SpyQv1kq8e4nJ5KokDCDwQABoMNDY2NjE4ODY2NjU4Igzt0lhGeLTOQvWsruQq5gJGFB/HzMrwDnjZ2z+J0PFoPkuecHi7WlSPYXKUz9smDW+wMPc/aKQlfrAdzv40AivwsnCPYHoDPpFopqnhGBlbljalg2P0f+d3oHEyL3CiPmzZxZ8mTaEIp5Ij8WA+GRXZ5PWSQ7YMTdv/mLenHXqd7LbUpdFzGQVZlcu+Dpanm/8mKPaDqX71ddKa0HkakqXlZXB1186TzEXMjg+qdKN6LJCzoFPlUMon1MecRE28Fs9QTFvAo3foj3Dts12hFRAajxwxS7yM8QVUJD24b1eUZ0opFR378YqFC172l6vb3Ej3LQMsD8q65ql4V0WuqJRnjvu3o3PM8WtQ4BW3U7mxSI/Hs+JI/u7mPyc4LqZGt2xyg4nMWP60WXuPHXJAYR2zilKLyTHzRxwEXESryntqvQLqGfpf8yE7h+5QolUTPX40Lfs/Ugv1knEpz83ktS8Gq8NIVGWDeaN9d/rv4UkCRivZ3ao0MJ3er6sGOqUBOuL7G4MhECk2cuhTZcuiQKVk3B4xyOkwccKlC9HeyWBRp1yTN5fp5fMDw01JnlSpERZBmvSPzgUy5N/b+OYFIOsi5uJ5/cRDeIWZH/2yh7aq2xwyYaJgINEB0HXAvkDNkagmMbUdhvc+LpBik1/W+/P0n9fQGu1CnXzKzNc52HMfUiA25CzHQTDAlI2CTh3JrZjMi9NoEf9ZISS2byOWOU7uORka'    \n            }\n        });\n\n        const peerConnection = createPeerConnection(iceServers, localView, remoteView);\n\n\n        // Set up signaling client event listeners and peer connection logic\n        // signalingClient.on('open', ...), signalingClient.on('sdpAnswer', ...), etc.\n\n        signalingClient.open();\n        signalingClient.on('open', async () => {\n            // Get a stream from the webcam, add it to the peer connection, and display it in the local view\n            try {\n                const localStream = await navigator.mediaDevices.getUserMedia({\n                    video: { width: { ideal: 1280 }, height: { ideal: 720 } },\n                    audio: true,\n                });\n                localStream.getTracks().forEach(track => peerConnection.addTrack(track, localStream));\n                localView.srcObject = localStream;\n            } catch (e) {\n                console.error(\"Error getting local stream:\", e);\n                return;\n            }\n        \n            // Create an SDP offer and send it to the master\n            const offer = await peerConnection.createOffer({\n                offerToReceiveAudio: true,\n                offerToReceiveVideo: true,\n            });\n            await peerConnection.setLocalDescription(offer);\n            signalingClient.sendSdpOffer(peerConnection.localDescription);\n        });\n        \n        // When the SDP answer is received back from the master, add it to the peer connection.\n        signalingClient.on('sdpAnswer', async answer => {\n            await peerConnection.setRemoteDescription(answer);\n        });\n        \n        // When an ICE candidate is received from the master, add it to the peer connection.\n        signalingClient.on('iceCandidate', candidate => {\n            peerConnection.addIceCandidate(candidate);\n        });\n        \n        return { signalingClient, peerConnection };\n    } catch (error) {\n        console.error('Error initializing WebRTC: ', error);\n    }\n}\nexport function cleanupWebRTC(signalingClient, peerConnection) {\n    if (signalingClient) {\n        signalingClient.close();\n    }\n    if (peerConnection) {\n        peerConnection.close();\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}